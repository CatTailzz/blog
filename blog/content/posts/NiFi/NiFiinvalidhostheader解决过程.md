---
title: NiFi invalid host header解决过程
subtitle: 
date: 2024-07-02T23:04:41+08:00
slug: 8c56445
tags:
  - NiFi
categories:
  - NiFI
password: 
message: 
draft: false
---
# 问题起因

最近需要在把NiFi集成到公司的一个中台上，因为NiFi本身是提供了一个可视化界面的，可以通过 `<ip>:port/nifi/` 这种路径去访问，所以我们计划使用前端跳转 + Nginx代理去实现。

但NiFi自从1.5版本之后多了一个host name校验机制，直接访问ip地址的结果如图所示

![image.png](https://obsidian-img-1300316500.cos.ap-shanghai.myqcloud.com/cattail/obsidian/pic/202407022313522.png)

这个问题什么时候会发生呢？主要是NiFi部署在Kubernetes上时。由于访问NiFi需要验证Host name，而大多数情况下，在Kubernetes集群中pod名称等于主机名，比如nifi-app-0这样的就是校验的期望值。这意味着只有当我的请求是 `https://nifi-app-0:8443/nifi/` 的时候，才能以正确的 `host name = nifi-app-0` 访问，但我如果从本机去访问远程就不能直接这么做，访问远程地址连个ip都不带怎么行？

当然这个问题仅仅发生在集群部署，如果我在一个远程服务器上直接部署，那么我在本地可以直接通过 `<ip>:<port>` 来访问，因为此时我的请求和需要校验的Host name是匹配的。

# 解决方案

## 最恶心，加host

这个做法的理由很直接，用ip能访问远程，但无法通过校验，用pod名能满足校验，但连ip都丢了。那么有没有一个两全的办法？答案很简单：就是改本机的host配置，加一条映射关系，这样用pod名去访问直接解析成了正确的ip，而且也能通过后续的校验。

但加配置总归是怪怪的行为，而且还是加在访问端的，再加上host文件的安全性，~~想帮忙篡改一下都难~~

## 最直接，改源码

技术狂热的人肯定上来就想，既然是个校验机制，NiFi又是Java写的，那直接进源码找到相关位置改掉不就好了吗。事实上真有人这么做了： [# NIFI-4761 Fixing test case regression. #2418](https://github.com/apache/nifi/pull/2418/commits/e1b5d93e8d3674a1c57c491d84903d4a669c9881) 。

但是仔细一想，这对吗，且不说拉个源码下来依赖装半天，再构建部署也是时间啊，而且后续如果发现XX框架和YY框架也有类似的机制，难道都去改源码？所以还是需要绕道。

## 从请求头入手

尝试对于错误的请求头进行观察，比如当我以 `https://<ip>:8443/nifi/` 去请求时，http客户端会解析得到 `<ip>:8443` ，并作为Header中的Host字段发送，也就是NiFi去校验的属性。那么我去修改请求头里的Host不就行了？

尝试在postman里把header的host字段修改为pod名，果然成功了。。立马通知运维，教他这么改一下就可以了，运维挠挠头，无奈的答应了。

## 终极解决方案

虽然已经越来越逼近真相，问题也越来越简化了，但工作量却还是有点大，我不清楚运维该怎么去实现，因为我是个nginx小白，让我实现肯定有点头痛。

继续探索最初的Error页面，发现答案就在谜面上，Error页面已经告诉了我们正确的host字段可以是哪些值。只是这些值我一个都无法作为请求路径去使用，像localhost、K8s内部地址、pod名这种都无法在本地直接访问，那能不能加一个我能用的？

尝试请教一下精通NiFi源码的gpt师傅，果然从不让我失望，在nifi的配置文件里，有一个代理相关的属性，proxy.host和proxy.port，我只要在这上面加上服务器的ip和port就可以了，相当于添加了一条校验规则，实在是妙。

# 思考

NiFi作为一个做数据同步的开源项目，在国内的讨论和教程非常少，我本以为冷门组件的问题会很难下手，但实际上跟我想象的不同。大多数问题并不出在组件内部，而是冷门组件与通用组件之间的交互，或者冷门组件中的通用模块。总结就一句话：知识是相通的，问题也是相通的。

还得是打好基础，剖析问题，思路灵活，精益求精✌️

